#include "stdafx.h"
#include <vector>
#include <string>
#include <initializer_list>
#include <memory>
#include <stdexcept>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>

using namespace std;
class Message;
void swap(Message &lhs, Message &rhs);

class Folder {
	set<Message *> m;
public:
	void addMsg(Message *v) {
		m.insert(v);
	}
	void remMsg(Message *v) {
		m.erase(v);
	}
};

class Message {
	friend class Folder;
	friend void swap(Message &lhs, Message &rhs);
public:
	explicit Message(const string & str=""):contents(str) { }
	Message(const Message &);
	Message & operator=(const Message &);
	~Message();
	void save(Folder &);
	void remove(Folder &);
	void addFolder(Folder *);
	void remFolder(Folder *);
private:
	string contents;
	set<Folder *> folders;
	void add_to_Folders(const Message &);
	void remove_from_Folders();
};

void Message::save(Folder & f) {
	folders.insert(&f);
	f.addMsg(this);
}

void Message::remove(Folder &f) {
	folders.erase(&f);
	f.remMsg(this);
}

void Message::add_to_Folders(const Message &m) {
	for (auto f : m.folders) {
		f->addMsg(this);
	}
}

void Message::addFolder(Folder * f) {
	folders.insert(f);
}

void Message::remFolder(Folder * f) {
	folders.erase(f);
}

Message::Message(const Message &m) :contents(m.contents), folders(m.folders) {
	add_to_Folders(m);
}

Message& Message::operator=(const Message &rhs) {
	remove_from_Folders();
	contents = rhs.contents;
	folders = rhs.folders;
	add_to_Folders(rhs);
	return *this;
}

void Message::remove_from_Folders() {
	for (auto f : folders)
		f->remMsg(this);
}

Message::~Message() {
	remove_from_Folders();
}

void swap(Message &lhs, Message &rhs) {
	for (auto f : lhs.folders) {
		f->remMsg(&lhs);
	}
	for (auto f : rhs.folders) {
		f->remMsg(&rhs);
	}
	swap(lhs.folders, rhs.folders);
	swap(lhs.contents, rhs.contents);
	for (auto f : lhs.folders) {
		f->addMsg(&lhs);
	}
	for(auto f:rhs.folders) {
		f->addMsg(&rhs);
	}
}

int main() {
	
}